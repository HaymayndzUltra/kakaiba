---
description: "TAGS: [fullstack,react,django,role-based,automation,end-to-end,framework-detection,safety-gates,contract-first] | TRIGGERS: FULLSTACK_INIT,BACKEND_DEFINE_DOMAIN,BACKEND_ADD_ENDPOINT,FRONTEND_ADD_PAGE,FRONTEND_ADD_COMPONENT,FULLSTACK_ADD_FEATURE,QUALITY_RUN_GATES,RELEASE_DEPLOY_STAGING,RELEASE_PROMOTE_PROD,DOCS_UPDATE,FRAMEWORK_DETECT,ROLE_ACTIVATE,SAFETY_GATE_EXECUTE | SCOPE: project-rules | DESCRIPTION: Comprehensive fullstack React + Django automation framework with role-based orchestration, safety gates, and end-to-end workflow coordination from idea to production with learning loops."
alwaysApply: false
---

# Fullstack React + Django Role-Based Automation Framework

## [STRICT] Framework Overview and Purpose

This framework implements **end-to-end automation** for fullstack React + Django applications with:
- **Role-based orchestration** with clear boundaries and capabilities
- **Framework auto-detection** and activation of appropriate RoleBundles  
- **Safety-first design** with comprehensive gates and quality checks
- **Contract-first handoffs** between frontend and backend
- **Namespace isolation** to prevent role conflicts
- **Predictable outputs** and audit trails for all operations

## [STRICT] Framework Detection and Activation

### FRAMEWORK_DETECT
- **Purpose**: Auto-detect React and Django signatures to activate appropriate RoleBundles
- **Detection Signals**:
  - **React**: package.json with React dependencies, src/pages or src/components directories
  - **Django**: manage.py file, Django config files, app/ and migrations/ folders
- **Process**:
  1. Scan repository structure for framework signatures
  2. Load appropriate roles, triggers, guardrails, and KPIs
  3. Isolate permissions per framework
  4. Activate namespace routing system
  5. Initialize safety gates and quality checks
- **Output**: Activated framework environment with role boundaries

## [STRICT] Role Catalog and Boundaries

### Frontend Roles (React)

#### FE Planner/Architect
- **Capabilities**: requirements.parse, routing.design, state.boundary.define, risk.assess
- **Boundaries**: Read-only analysis, planning documents, architecture decisions
- **Outputs**: Requirements spec, routing plan, state boundaries, risk assessment

#### UI/Component Developer  
- **Capabilities**: component.create, design.pattern.implement, prop.contract.define
- **Boundaries**: src/components/, src/ui/, design system files
- **Outputs**: Reusable components, prop contracts, component documentation

#### State & Forms Manager
- **Capabilities**: state.hook.create, form.schema.define, validation.implement, optimistic.update
- **Boundaries**: src/hooks/, src/store/, src/forms/, validation schemas
- **Outputs**: Data hooks, form schemas, validation logic, state management

#### Routing/SEO Specialist
- **Capabilities**: route.define, guard.implement, metadata.optimize, sitemap.generate
- **Boundaries**: src/routes/, src/pages/, SEO configuration files
- **Outputs**: Routes, guards, metadata, sitemap, robots.txt

#### Accessibility (A11y) Engineer
- **Capabilities**: semantics.implement, focus.manage, keyboard.flow.design, aria.configure
- **Boundaries**: A11y attributes, focus management, keyboard navigation
- **Outputs**: Accessible components, focus flows, A11y test suites

#### Performance Engineer
- **Capabilities**: code.split, memoization.implement, image.optimize, budget.enforce
- **Boundaries**: Performance optimizations, bundle analysis, image pipeline
- **Outputs**: Optimized components, performance budgets, loading strategies

#### FE Testing Engineer
- **Capabilities**: test.unit, test.interaction, test.snapshot, test.visual, test.a11y
- **Boundaries**: src/__tests__/, test specifications, coverage reports
- **Outputs**: Test suites, coverage reports, visual regression tests

#### FE Documentation Specialist
- **Capabilities**: doc.component.write, story.create, changelog.update, guide.usage
- **Boundaries**: Documentation files, Storybook stories, usage guides
- **Outputs**: Component docs, stories, usage guidelines, change notes

### Backend Roles (Django)

#### BE Architect
- **Capabilities**: app.boundary.define, settings.configure, risk.control.implement
- **Boundaries**: Django project structure, settings files, architecture decisions
- **Outputs**: App boundaries, settings matrix, risk controls, architecture docs

#### ORM/Model Developer
- **Capabilities**: model.define, constraint.implement, relation.establish, index.optimize
- **Boundaries**: models.py files, database schema, ORM configurations
- **Outputs**: Django models, constraints, relationships, database indexes

#### Migration Safety Engineer
- **Capabilities**: migration.plan, migration.apply.safe, migration.rollback, destructive.block
- **Boundaries**: migrations/ directories, database operations, safety checks
- **Outputs**: Safe migrations, rollback plans, migration documentation

#### API/Contracts Developer
- **Capabilities**: api.endpoint.create, schema.define, pagination.implement, version.manage
- **Boundaries**: API views, serializers, URL configurations, API documentation
- **Outputs**: REST/GraphQL endpoints, API contracts, pagination, versioning

#### Auth & Security Engineer  
- **Capabilities**: auth.configure, rbac.implement, session.manage, privacy.enforce
- **Boundaries**: Authentication, authorization, security middleware, privacy controls
- **Outputs**: Auth systems, RBAC policies, security configurations, privacy gates

#### Jobs/Queues Engineer
- **Capabilities**: job.define, queue.configure, retry.implement, schedule.manage
- **Boundaries**: Background tasks, queue configurations, job scheduling
- **Outputs**: Background jobs, retry logic, schedules, queue monitoring

#### Caching Engineer
- **Capabilities**: cache.define, ttl.configure, invalidation.implement, hierarchy.design
- **Boundaries**: Cache configurations, invalidation logic, cache hierarchies
- **Outputs**: Cache strategies, TTL configurations, invalidation hooks

#### BE Testing Engineer
- **Capabilities**: test.unit, test.integration, test.contract, fixture.create
- **Boundaries**: Backend test files, test databases, fixtures, test configurations
- **Outputs**: Unit tests, integration tests, contract tests, test fixtures

#### BE Documentation Specialist
- **Capabilities**: api.doc.generate, runbook.write, adr.record, changelog.maintain
- **Boundaries**: API documentation, runbooks, ADRs, technical documentation
- **Outputs**: API docs, runbooks, ADRs, technical specifications

### Cross-Cutting Roles

#### DevOps/SRE Engineer
- **Capabilities**: ci.setup, pipeline.configure, deploy.strategy.implement, rollback.prepare
- **Boundaries**: CI/CD configurations, deployment scripts, infrastructure code
- **Outputs**: CI/CD pipelines, deployment strategies, rollback procedures

#### QA/Audit Specialist
- **Capabilities**: validation.execute, evidence.capture, acceptance.verify, compliance.check
- **Boundaries**: Quality gates, audit trails, compliance checks, validation reports
- **Outputs**: Validation reports, evidence capture, compliance status

#### Security/Privacy Engineer
- **Capabilities**: security.scan, vulnerability.assess, secret.manage, privacy.audit
- **Boundaries**: Security configurations, secret management, privacy controls
- **Outputs**: Security scans, vulnerability reports, secret management, privacy audits

#### Observability/Analytics Engineer
- **Capabilities**: monitoring.configure, dashboard.create, analytics.implement, alert.setup
- **Boundaries**: Monitoring configurations, dashboards, analytics, alerting
- **Outputs**: Monitoring setup, dashboards, analytics, alert configurations

#### Release Manager
- **Capabilities**: version.manage, changelog.generate, approval.coordinate, communication.manage
- **Boundaries**: Release processes, versioning, approvals, release communications
- **Outputs**: Version management, changelogs, approval workflows, release notes

## [STRICT] Command Triggers and Routing

### Central Router System
- **Namespace Isolation**: "frontend:", "backend:", "fullstack:" prefixes
- **Precedence Order**: project overrides → framework rules → core defaults
- **Conflict Resolution**: Clear ownership, single writer per path
- **Cross-Framework Coordination**: Orchestrated workflows for features spanning both stacks

### Core Triggers

#### FULLSTACK_INIT
- **Purpose**: Initialize complete fullstack project with baseline setup
- **Command**: `fullstack:init project`
- **Process**:
  1. Scaffold React frontend structure
  2. Scaffold Django backend structure  
  3. Configure development environment
  4. Set up initial CI/CD pipeline
  5. Initialize documentation structure
  6. Configure safety gates and quality checks
- **Roles Involved**: FE Architect, BE Architect, DevOps Engineer
- **Outputs**: Complete project scaffold, development environment, CI/CD setup

#### BACKEND_DEFINE_DOMAIN
- **Purpose**: Define backend domain entities with models, migrations, and contracts
- **Command**: `backend:define domain <Entity>`
- **Process**:
  1. Create Django models with constraints
  2. Generate safe migrations
  3. Define API contracts and serializers
  4. Create unit and integration tests
  5. Generate API documentation
- **Roles Involved**: ORM Developer, Migration Engineer, API Developer, BE Testing Engineer
- **Outputs**: Models, migrations, API contracts, tests, documentation

#### BACKEND_ADD_ENDPOINT  
- **Purpose**: Add new API endpoint with full implementation
- **Command**: `backend:add endpoint <Method> <Path>`
- **Process**:
  1. Create view handlers and business logic
  2. Implement request/response validation
  3. Add authentication and authorization
  4. Create comprehensive tests
  5. Update API documentation
- **Roles Involved**: API Developer, Auth Engineer, BE Testing Engineer, BE Documentation
- **Outputs**: API endpoints, validation, auth, tests, documentation

#### FRONTEND_ADD_PAGE
- **Purpose**: Create new frontend page with data integration
- **Command**: `frontend:add page <Route>`
- **Process**:
  1. Create page component with routing
  2. Implement data hooks and state management
  3. Add accessibility features
  4. Implement performance optimizations
  5. Create A11y and performance tests
- **Roles Involved**: UI Developer, State Manager, Routing Specialist, A11y Engineer, Performance Engineer
- **Outputs**: Page component, data hooks, A11y tests, performance budgets

#### FRONTEND_ADD_COMPONENT
- **Purpose**: Create reusable frontend component
- **Command**: `frontend:add component <Name>`
- **Process**:
  1. Design component API and prop contracts
  2. Implement component with accessibility
  3. Create unit and interaction tests
  4. Generate component documentation and stories
  5. Add to design system
- **Roles Involved**: UI Developer, A11y Engineer, FE Testing Engineer, FE Documentation
- **Outputs**: Component, prop contracts, tests, documentation, stories

#### FULLSTACK_ADD_FEATURE
- **Purpose**: Orchestrated full-stack feature implementation
- **Command**: `fullstack:add feature <Name>`
- **Process**:
  1. Define feature requirements and contracts
  2. Backend implementation (models, APIs, tests)
  3. Frontend implementation (UI, data hooks, tests)
  4. Integration testing and validation
  5. Documentation and deployment preparation
- **Roles Involved**: All relevant frontend and backend roles, coordinated by Release Manager
- **Outputs**: Complete feature implementation across both stacks

#### QUALITY_RUN_GATES
- **Purpose**: Execute comprehensive quality and safety checks
- **Command**: `quality:run gates`
- **Process**:
  1. Frontend quality checks (lint, type, A11y, performance)
  2. Backend quality checks (style, tests, security, performance)
  3. Security scanning (secrets, dependencies, SAST)
  4. Documentation validation
  5. Generate quality reports
- **Roles Involved**: QA Engineer, Security Engineer, Performance Engineers
- **Outputs**: Quality reports, compliance status, gate results

#### RELEASE_DEPLOY_STAGING
- **Purpose**: Deploy to staging environment with validation
- **Command**: `release:deploy staging`
- **Process**:
  1. Build and package applications
  2. Execute safe database migrations
  3. Deploy to staging environment
  4. Run smoke tests and validation
  5. Generate deployment report
- **Roles Involved**: DevOps Engineer, Migration Engineer, QA Engineer
- **Outputs**: Staging deployment, smoke test results, deployment report

#### RELEASE_PROMOTE_PROD
- **Purpose**: Promote to production with canary and rollback capabilities
- **Command**: `release:promote prod`
- **Process**:
  1. Execute canary deployment
  2. Monitor SLOs and key metrics
  3. Gradual traffic promotion or automatic rollback
  4. Update documentation and changelogs
  5. Notify stakeholders
- **Roles Involved**: DevOps Engineer, Observability Engineer, Release Manager
- **Outputs**: Production deployment, monitoring dashboards, release notes

#### DOCS_UPDATE
- **Purpose**: Update all documentation across the stack
- **Command**: `docs:update`
- **Process**:
  1. Update API documentation
  2. Generate/update changelogs
  3. Update runbooks and procedures
  4. Record architectural decisions
  5. Update user guides
- **Roles Involved**: Documentation Specialists, API Developer, Release Manager
- **Outputs**: Updated documentation, changelogs, runbooks, ADRs

## [STRICT] Safety Gates and Quality Checks

### Pre-Execution Gates
- **Risk Assessment**: Evaluate potential impact and complexity
- **Permission Validation**: Verify role permissions and boundaries
- **Dependency Analysis**: Check for conflicts and prerequisites
- **Security Scanning**: Validate inputs and detect security risks

### During-Execution Monitoring
- **Progress Tracking**: Monitor execution progress and performance
- **Anomaly Detection**: Detect unusual patterns or behaviors  
- **Budget Enforcement**: Enforce performance, accessibility, and latency budgets
- **Resource Monitoring**: Track resource usage and limits

### Post-Execution Validation
- **Requirements Validation**: Verify outputs match requirements
- **Contract Testing**: Validate API contracts and integrations
- **Policy Compliance**: Check against release and security policies
- **Human Approval**: Required for high-risk operations (destructive migrations, production promotion)

### Quality Gate Thresholds

#### Frontend Quality Gates
- **Linting/Type Checking**: Must pass with zero errors
- **Accessibility Score**: ≥ 95% compliance
- **Lighthouse Performance**: ≥ 90 score
- **Bundle Size**: Within defined budget limits
- **Core Web Vitals**: CLS, LCP, FID within budget

#### Backend Quality Gates  
- **Code Style/Linting**: Must pass with zero errors
- **Test Coverage**: ≥ 85-90% coverage requirement
- **Migration Safety**: All migrations must pass safety checks
- **Performance**: p95 latency ≤ 200ms (configurable)
- **Security**: Zero critical vulnerabilities

#### Security Gates
- **Secret Scanning**: Zero secrets in code or artifacts
- **Dependency Audit**: No critical vulnerabilities
- **SAST Rules**: Pass static analysis security testing
- **Privacy Compliance**: Data classification and handling compliance

#### Documentation Gates
- **API Documentation**: Must be updated for API changes
- **ADR Records**: Architectural decisions must be documented
- **Runbooks**: Operational procedures must be current
- **Changelog**: Changes must be documented before release

## [STRICT] Handoff Protocols and Contract Management

### Contract-First Development
1. **Backend Contract Publication**: API schemas, data models, error formats
2. **Frontend Contract Consumption**: Forms, hooks, UI components based on contracts
3. **Versioned Handoffs**: Clear versioning and backward compatibility
4. **Source of Truth**: Single source for contracts to prevent drift

### Integration Flow
1. **Backend Development**: Models → Migrations → API endpoints → Tests → Documentation
2. **Contract Publication**: API contracts published and versioned
3. **Frontend Development**: Data hooks → UI components → Forms → Tests → Documentation  
4. **Integration Validation**: Contract testing, end-to-end validation
5. **Deployment Coordination**: Staging → Canary → Production with rollback capability

## [STRICT] Permissions and Boundaries

### File Scope Restrictions
- **Frontend Roles**: Write access only to frontend directories (src/, public/, frontend configs)
- **Backend Roles**: Write access only to backend directories (Django apps, migrations, backend configs)
- **Cross-cutting Roles**: Limited write access to their specific domain files
- **No Cross-Stack Writes**: Strict enforcement of role boundaries

### Tool Scope Restrictions
- **Frontend Roles**: JavaScript/TypeScript toolchain, frontend build tools
- **Backend Roles**: Python toolchain, Django management commands, database tools
- **DevOps Roles**: Build/deploy tools, infrastructure management tools
- **Security Roles**: Security scanning tools, secret management tools

### Network Scope Restrictions
- **Default Block**: All network access blocked by default
- **Whitelist Model**: Explicitly allow required network access (package registries, APIs)
- **Audit Trail**: All network access logged and monitored
- **Secret Management**: Read-only access via secure broker, no raw secrets in logs

## [STRICT] KPIs and Success Metrics

### Global Performance Metrics
- **Role Activation**: < 2 seconds
- **Task Assignment Success**: > 95%
- **Error Budget Burn**: < 1% per day
- **Coordination Efficiency**: > 95%
- **Safety Compliance**: 100%

### Frontend-Specific Metrics
- **Accessibility Score**: ≥ 95%
- **Lighthouse Performance**: ≥ 90
- **Core Web Vitals**: Within budget (CLS, LCP, FID)
- **Bundle Size**: Within defined limits
- **Build Time**: Optimized for developer experience

### Backend-Specific Metrics
- **API Response Time**: p95 ≤ 200ms (configurable)
- **Error Rate**: ≤ 0.5%
- **Test Coverage**: ≥ 85-90%
- **Database Query Performance**: Optimized with proper indexing
- **Migration Safety**: 100% safe migrations

### Security Metrics
- **Critical Vulnerabilities**: 0 tolerance
- **Secret Exposure**: 0 tolerance
- **Policy Exceptions**: Approval-only with documented justification
- **Security Scan Coverage**: 100% of code and dependencies

### Documentation and Learning Metrics
- **Documentation Currency**: ≤ 1 day lag from code changes
- **Learning Effectiveness**: > 90% pattern recognition accuracy
- **User Satisfaction**: ≥ 4.5/5 rating
- **Knowledge Base Growth**: Continuous improvement in automation patterns

## [STRICT] Approval Workflows and Human-in-the-Loop

### High-Risk Operations Requiring Approval
- **Destructive Database Migrations**: Schema drops, column removal, data deletion
- **Production Deployments**: Final production promotion approval
- **Security Policy Changes**: Changes to authentication, authorization, or security configurations
- **Privacy-Sensitive Operations**: Data handling, user data access, privacy policy changes

### Approval Process
1. **Automated Risk Assessment**: Evaluate operation risk level
2. **Evidence Collection**: Gather test results, security scans, performance metrics
3. **Stakeholder Notification**: Alert appropriate approvers with evidence package
4. **Approval Decision**: Human review and approval/rejection with rationale
5. **Execution or Rejection**: Proceed with approved operations or handle rejections
6. **Audit Trail**: Complete audit trail of approval process and decisions

### Escalation Procedures
- **Failed Operations**: Automatic escalation with detailed failure analysis
- **Security Incidents**: Immediate escalation to security team
- **Performance Degradation**: Escalation to performance engineering team
- **System Outages**: Follow incident response procedures with defined escalation tree

## [STRICT] CI/CD Integration and Path-Based Execution

### Path-Based Filtering
- **Frontend Changes**: Trigger only frontend-specific checks and deployments
- **Backend Changes**: Trigger only backend-specific checks and deployments
- **Cross-Stack Changes**: Trigger full-stack validation and integration tests
- **Documentation Changes**: Trigger documentation builds and validation

### Required Checks by Layer

#### Frontend CI Pipeline
- **Linting and Type Checking**: ESLint, TypeScript, Prettier
- **Unit and Interaction Tests**: Jest, React Testing Library
- **Accessibility Testing**: Automated A11y audits
- **Performance Budgets**: Bundle size, Core Web Vitals validation
- **Visual Regression**: Screenshot comparison tests

#### Backend CI Pipeline  
- **Code Style and Linting**: Black, flake8, isort, mypy
- **Unit and Integration Tests**: pytest, coverage reporting
- **Migration Safety**: Automated migration safety checks
- **Contract Testing**: API contract validation
- **Performance Testing**: Latency and throughput validation

#### Security CI Pipeline
- **Secret Scanning**: GitLeaks, TruffleHog
- **Dependency Auditing**: Safety, Bandit, npm audit
- **Static Application Security Testing**: SAST tools
- **Container Security**: Container image scanning

### Release Pipeline
1. **Staging Deployment**: Automated deployment with seeded data and smoke tests
2. **Integration Testing**: Full end-to-end test suite execution
3. **Security Validation**: Final security scans and compliance checks
4. **Canary Deployment**: Gradual traffic shifting with SLO monitoring
5. **Production Promotion**: Full promotion or automatic rollback based on metrics
6. **Post-Deployment Monitoring**: Continuous monitoring and alerting

## [STRICT] Learning and Continuous Improvement

### Pattern Recognition and Learning
- **Automation Pattern Analysis**: Identify successful automation patterns
- **Failure Analysis**: Learn from failed operations and improve procedures
- **User Behavior Analysis**: Adapt to user preferences and working patterns
- **Performance Optimization**: Continuously improve based on performance data

### Rule Evolution and Enhancement
- **Dynamic Rule Generation**: Generate new rules based on learned patterns
- **Rule Refinement**: Improve existing rules based on usage feedback
- **Context Adaptation**: Adapt rules to different project contexts and requirements
- **Safety Improvement**: Enhance safety protocols based on incident analysis

### Knowledge Base Development
- **Best Practices Documentation**: Capture and share successful patterns
- **Anti-Pattern Identification**: Document and prevent common mistakes
- **Technology Evolution**: Adapt to new technologies and methodologies
- **Community Learning**: Learn from broader community practices and standards

## [STRICT] Error Handling and Recovery

### Error Detection and Classification
- **Syntax Errors**: Code compilation and linting failures
- **Runtime Errors**: Application execution failures
- **Integration Errors**: API contract violations and communication failures
- **Performance Errors**: Budget violations and performance degradation
- **Security Errors**: Vulnerability detection and policy violations

### Recovery Strategies
- **Automatic Retry**: Retry transient failures with exponential backoff
- **Graceful Degradation**: Fallback to simplified functionality when possible
- **Rollback Procedures**: Automatic rollback for failed deployments
- **Circuit Breaker**: Prevent cascade failures in distributed systems
- **Manual Intervention**: Escalate to human operators when automatic recovery fails

### Incident Response
- **Immediate Detection**: Real-time monitoring and alerting
- **Rapid Response**: Automated initial response and notification
- **Investigation**: Detailed root cause analysis and documentation
- **Resolution**: Systematic problem resolution with validation
- **Post-Incident Review**: Learning and improvement process

## [STRICT] Implementation Guidelines and Best Practices

### Role Implementation
1. **Clear Capability Definition**: Define specific capabilities and boundaries for each role
2. **Minimal Permissions**: Implement least-privilege access principles
3. **Predictable Outputs**: Ensure consistent and predictable outputs from each role
4. **Error Boundaries**: Implement proper error handling and isolation
5. **Audit Logging**: Comprehensive logging of all role actions and decisions

### Trigger Implementation
1. **Consistent Naming**: Use clear, predictable naming conventions
2. **Parameter Validation**: Validate all input parameters and contexts
3. **Progress Tracking**: Provide real-time progress feedback
4. **Rollback Capability**: Ensure all operations can be safely rolled back
5. **Documentation**: Maintain comprehensive trigger documentation

### Integration Best Practices
1. **Contract Validation**: Strict validation of all contracts and interfaces
2. **Version Management**: Proper versioning and backward compatibility
3. **Health Checks**: Continuous health monitoring and validation
4. **Performance Monitoring**: Real-time performance metrics and alerting
5. **Security Scanning**: Continuous security scanning and validation

This comprehensive framework provides **end-to-end automation** for fullstack React + Django applications with **role-based orchestration**, **safety-first design**, and **predictable, maintainable workflows** that scale from development to production! 🚀