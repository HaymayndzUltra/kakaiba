---
description: "TAGS: [automation,analysis,workflow,orchestration,ai-rule-generation] | TRIGGERS: MAKE_AUTO_BRIEF,GENERATE_AUTOMATION,CREATE_FLOW,ANALYZE_PROJECT,GENERATE_RULES,ADVANCE_RULES,LEARN_FROM_PROMPT | SCOPE: project-rules | DESCRIPTION: Analyze project briefs, generate connected automation workflows, and dynamically create advanced AI rules based on learned patterns."
alwaysApply: false
---

# Advanced Automation Workflow Analyzer with Dynamic Rule Generation

## [STRICT] Purpose and Scope
- Analyze project briefs or end-to-end tasks to identify automation opportunities
- Generate multiple system instructions with specific triggers for connected workflows
- **DYNAMIC RULE GENERATION**: Create new, advanced AI rules based on learned patterns from prompts
- **SELF-IMPROVEMENT**: Continuously evolve and enhance automation capabilities
- Focus on analysis-driven workflow generation and intelligent automation optimization

## [STRICT] Core Capabilities

### 1. Project Analysis Engine
- **Input Processing**: Parse project briefs, requirements, and task descriptions
- **Pattern Recognition**: Identify repetitive tasks, dependencies, and automation candidates
- **Complexity Assessment**: Evaluate task complexity and automation feasibility
- **Technology Stack Analysis**: Determine appropriate tools and frameworks for automation
- **Learning Integration**: Extract patterns for rule generation

### 2. Automation Generation
- **Workflow Design**: Create connected automation sequences
- **Trigger Definition**: Generate specific command triggers for each automation step
- **Dependency Mapping**: Establish proper sequencing and prerequisites
- **Integration Points**: Identify where automations connect and hand off
- **Rule Integration**: Embed learned patterns into automation workflows

### 3. Dynamic Rule Generation Engine
- **Pattern Learning**: Analyze prompts to identify reusable patterns
- **Rule Synthesis**: Generate new AI rules based on learned patterns
- **Advanced Capabilities**: Create more sophisticated automation rules
- **Context Awareness**: Adapt rules based on project context and requirements
- **Continuous Evolution**: Improve rules based on usage patterns and feedback

### 4. System Instruction Creation
- **Modular Instructions**: Generate focused, single-purpose system instructions
- **Triggerable Commands**: Create specific user commands for each automation
- **Context Preservation**: Maintain project context across automation chains
- **Error Handling**: Include fallback and recovery mechanisms
- **Learning Integration**: Incorporate learned patterns into instructions

## [STRICT] Enhanced Command Triggers

### MAKE_AUTO_BRIEF
- **Purpose**: Convert project brief into automation-ready format with learning
- **Input**: Raw project brief or requirements document
- **Output**: Structured brief with automation opportunities and learning insights
- **Process**:
  1. Parse and structure the input brief
  2. Identify automation candidates (repetitive tasks, dependencies)
  3. Extract key entities, workflows, and integration points
  4. **LEARN**: Identify patterns that could become reusable rules
  5. Generate automation-ready brief with metadata and learning insights

### GENERATE_AUTOMATION
- **Purpose**: Create specific automation workflows from analyzed brief
- **Input**: Automation-ready brief from MAKE_AUTO_BRIEF
- **Output**: Detailed automation specifications with triggers and learned patterns
- **Process**:
  1. Analyze automation opportunities
  2. Design workflow sequences
  3. Define trigger commands
  4. Specify integration points and handoffs
  5. **LEARN**: Extract patterns for rule generation
  6. Generate implementation specifications with learning metadata

### CREATE_FLOW
- **Purpose**: Generate complete automation flow with system instructions
- **Input**: Automation specifications from GENERATE_AUTOMATION
- **Output**: Executable automation flow with all system instructions
- **Process**:
  1. Create system instruction templates
  2. Define trigger command mappings
  3. Establish flow control and error handling
  4. **LEARN**: Incorporate learned patterns into instructions
  5. Generate complete automation package
  6. Provide execution guidance with learning insights

### ANALYZE_PROJECT
- **Purpose**: Deep analysis of existing project for automation opportunities
- **Input**: Project codebase, documentation, or configuration
- **Output**: Comprehensive automation analysis report with learning insights
- **Process**:
  1. Scan project structure and dependencies
  2. Identify automation patterns and opportunities
  3. Analyze existing workflows and bottlenecks
  4. **LEARN**: Extract patterns for rule generation
  5. Generate optimization recommendations
  6. Create automation roadmap with learning insights

### **NEW: GENERATE_RULES**
- **Purpose**: Generate new AI rules based on learned patterns from prompts
- **Input**: Learned patterns from previous analyses or specific prompt
- **Output**: New, advanced AI rules that can be used for future automations
- **Process**:
  1. Analyze learned patterns and prompt structures
  2. Identify reusable rule templates
  3. Generate rule metadata (TAGS, TRIGGERS, SCOPE)
  4. Create rule content with proper formatting
  5. Validate rule compatibility with existing system
  6. Output ready-to-use rule files

### **NEW: ADVANCE_RULES**
- **Purpose**: Enhance existing rules based on new learning and patterns
- **Input**: Existing rule + new patterns/insights
- **Output**: Enhanced version of the rule with new capabilities
- **Process**:
  1. Analyze existing rule structure and capabilities
  2. Identify enhancement opportunities from new patterns
  3. Generate improved rule content
  4. Maintain backward compatibility
  5. Add new triggers and capabilities
  6. Output enhanced rule file

### **NEW: LEARN_FROM_PROMPT**
- **Purpose**: Extract learning from a single prompt to generate rules
- **Input**: Any prompt or instruction
- **Output**: Generated rules based on prompt analysis
- **Process**:
  1. Parse the input prompt for patterns and requirements
  2. Identify automation opportunities
  3. Extract reusable rule templates
  4. Generate appropriate rule metadata
  5. Create rule content based on prompt analysis
  6. Output multiple rule variations if applicable

## [STRICT] Learning and Pattern Recognition

### Pattern Extraction
- **Prompt Analysis**: Identify common patterns in user prompts
- **Workflow Patterns**: Recognize recurring automation sequences
- **Integration Patterns**: Learn how different systems connect
- **Error Patterns**: Identify common failure points and solutions
- **Optimization Patterns**: Learn efficiency improvements

### Rule Generation Templates
```yaml
rule_template:
  metadata:
    description: "TAGS: [learned_tags] | TRIGGERS: [learned_triggers] | SCOPE: [appropriate_scope] | DESCRIPTION: [learned_description]"
    alwaysApply: false
  
  content:
    purpose: "[extracted_purpose]"
    capabilities: "[learned_capabilities]"
    triggers: "[learned_triggers]"
    process: "[learned_process]"
    integration: "[learned_integration]"
    safety: "[learned_safety]"
```

### Learning Integration
- **Context Awareness**: Adapt rules based on project context
- **Technology Stack**: Generate rules specific to detected tech stacks
- **Industry Patterns**: Learn industry-specific automation patterns
- **User Preferences**: Adapt to user's working style and preferences
- **Feedback Loop**: Improve rules based on usage feedback

## [STRICT] Advanced Output Specifications

### Enhanced Automation Brief Format
```yaml
project_metadata:
  name: string
  type: string
  complexity: low|medium|high
  automation_score: 0-100
  learning_insights: string[]

automation_opportunities:
  - id: string
    type: workflow|integration|optimization
    description: string
    complexity: low|medium|high
    estimated_effort: hours
    dependencies: string[]
    triggers: string[]
    learned_patterns: string[]
    potential_rules: string[]

workflow_sequences:
  - name: string
    steps: automation_step[]
    triggers: string[]
    integration_points: string[]
    error_handling: string[]
    learned_optimizations: string[]

generated_rules:
  - rule_name: string
    rule_type: automation|workflow|integration|optimization
    triggers: string[]
    capabilities: string[]
    generated_from: string
    confidence_score: 0-100
```

### Dynamic Rule Generation Format
```markdown
---
description: "TAGS: [learned_tags] | TRIGGERS: [learned_triggers] | SCOPE: [appropriate_scope] | DESCRIPTION: [learned_description]"
alwaysApply: false
---

# [Generated Rule Name]

## [STRICT] Purpose
[Generated purpose based on learned patterns]

## [STRICT] Learned Capabilities
[Capabilities extracted from prompt analysis]

## [STRICT] Triggers
- [LEARNED_TRIGGER1]: [Description based on pattern analysis]
- [LEARNED_TRIGGER2]: [Description based on pattern analysis]

## [STRICT] Process
[Process generated from learned patterns]

## [STRICT] Integration Points
[Integration points learned from analysis]

## [STRICT] Error Handling
[Error handling patterns learned from analysis]

## [STRICT] Learning Metadata
- Generated from: [source_prompt_or_pattern]
- Confidence score: [0-100]
- Last updated: [timestamp]
- Usage count: [number]
```

## [STRICT] Self-Improvement Mechanisms

### Continuous Learning
- **Pattern Accumulation**: Build database of learned patterns
- **Rule Evolution**: Continuously improve existing rules
- **Capability Expansion**: Add new capabilities based on learning
- **Optimization**: Improve efficiency based on usage patterns
- **Adaptation**: Adapt to new technologies and methodologies

### Feedback Integration
- **Success Metrics**: Track successful automation outcomes
- **Failure Analysis**: Learn from failed automations
- **User Feedback**: Incorporate user suggestions and improvements
- **Performance Metrics**: Optimize based on performance data
- **Usage Patterns**: Adapt to how users actually use the system

### Rule Validation
- **Compatibility Check**: Ensure new rules work with existing system
- **Conflict Detection**: Identify and resolve rule conflicts
- **Quality Assurance**: Validate rule quality and completeness
- **Testing**: Test generated rules before deployment
- **Rollback Capability**: Ability to revert problematic rules

## [STRICT] Advanced Safety and Bounds

### Learning Safety
- **Pattern Validation**: Validate learned patterns before rule generation
- **Security Review**: Ensure learned patterns don't introduce security risks
- **Quality Gates**: Implement quality checks for generated rules
- **Human Oversight**: Require human approval for critical rule changes
- **Audit Trail**: Track all rule generation and modifications

### Operational Bounds
- **Resource Limits**: Respect system resource constraints for learning
- **Rate Limiting**: Limit rule generation frequency
- **Storage Management**: Manage rule storage and cleanup
- **Version Control**: Track rule versions and changes
- **Backup and Recovery**: Maintain rule backups and recovery procedures

## [STRICT] Success Metrics

### Learning Effectiveness
- **Pattern Recognition Accuracy**: How well patterns are identified
- **Rule Generation Quality**: Quality of generated rules
- **Automation Improvement**: Improvement in automation effectiveness
- **User Satisfaction**: User satisfaction with generated rules
- **System Performance**: Impact on overall system performance

### Continuous Improvement
- **Learning Rate**: How quickly the system learns new patterns
- **Rule Evolution**: How well rules evolve and improve
- **Adaptation Speed**: How quickly the system adapts to new requirements
- **Error Reduction**: Reduction in automation errors over time
- **Efficiency Gains**: Measurable efficiency improvements

## [STRICT] Implementation Guidelines

### Rule Generation Process
1. **Pattern Analysis**: Analyze input for reusable patterns
2. **Template Selection**: Choose appropriate rule template
3. **Content Generation**: Generate rule content based on patterns
4. **Validation**: Validate generated rule for quality and compatibility
5. **Testing**: Test rule functionality before deployment
6. **Deployment**: Deploy validated rule to system

### Learning Integration
1. **Pattern Extraction**: Extract patterns from all inputs
2. **Pattern Storage**: Store patterns in searchable database
3. **Pattern Analysis**: Analyze patterns for rule generation opportunities
4. **Rule Synthesis**: Generate rules from analyzed patterns
5. **Rule Integration**: Integrate new rules into existing system
6. **Feedback Loop**: Collect feedback and improve learning process

## [STRICT] Example Usage Scenarios

### Scenario 1: Learning from a Complex Prompt

User: "Create a full-stack e-commerce platform with React, Node.js, PostgreSQL, Stripe integration, admin dashboard, real-time notifications, and automated testing"
LEARN_FROM_PROMPT → Analyzes the prompt and generates:
E-commerce automation rules
Payment integration rules
Real-time notification rules
Admin dashboard rules
Testing automation rules

### Scenario 2: Pattern-Based Rule Generation
User: "I need to automate the deployment process for my microservices"
GENERATE_RULES → Analyzes deployment patterns and generates:
Microservices deployment rules
CI/CD pipeline rules
Container orchestration rules
Monitoring and logging rules

### Scenario 3: Continuous Learning and Improvement

User: "The previous automation didn't handle error cases well"
ADVANCE_RULES → Analyzes the feedback and enhances existing rules:
Adds better error handling
Improves recovery mechanisms
Adds more robust validation
Enhances logging and monitoring


This enhanced rule now includes **dynamic rule generation** capabilities that allow the AI to learn from prompts and create more advanced, context-aware automation rules automatically! 🚀

The enhanced rule now includes:
�� NEW CAPABILITIES
1. GENERATE_RULES - Dynamic Rule Creation
Analyzes any prompt and generates new AI rules
Learns patterns and creates reusable rule templates
Generates rules specific to the detected technology stack
2. ADVANCE_RULES - Rule Enhancement
Takes existing rules and makes them more advanced
Incorporates new learning and patterns
Maintains backward compatibility while adding new capabilities
3. LEARN_FROM_PROMPT - Single Prompt Learning
Extracts learning from any single prompt
Generates multiple rule variations
Creates context-aware automation rules
�� Self-Improvement Features
Pattern Recognition: Learns from every interaction
Rule Evolution: Continuously improves existing rules
Context Awareness: Adapts to different project types
Feedback Integration: Learns from user feedback
Continuous Learning: Builds knowledge base over time
💡 Practical Examples
Example 1: Learning from E-commerce Prompt

Input: "Create a full-stack e-commerce platform with React, Node.js, PostgreSQL, Stripe integration, admin dashboard, real-time notifications, and automated testing"

Output: Generates 5+ specialized rules:
- E-commerce automation rules
- Payment integration rules  
- Real-time notification rules
- Admin dashboard rules
- Testing automation rules

Example 2: Pattern-Based Enhancement

Input: "I need to automate the deployment process for my microservices"

Output: Generates deployment-focused rules:
- Microservices deployment rules
- CI/CD pipeline rules
- Container orchestration rules
- Monitoring and logging rules